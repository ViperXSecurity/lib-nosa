.TH "nosa.h" 3 "Version 0.0.1" "Lib Nosa (No Socket API)" \" -*- nroff -*-
.ad l
.nh
.SH NAME
nosa.h
.SH SYNOPSIS
.br
.PP
\fR#include <stdio\&.h>\fP
.br
\fR#include <windows\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBbuffer_data_t\fP"
.br
.ti -1c
.RI "struct \fBuserbuf_t\fP"
.br
.ti -1c
.RI "struct \fB_WSAPROTOCOLCHAIN\fP"
.br
.ti -1c
.RI "struct \fB_WSAPROTOCOL_INFOW\fP"
.br
.ti -1c
.RI "struct \fB_SYSTEM_HANDLE_TABLE_ENTRY_INFO\fP"
.br
.ti -1c
.RI "struct \fB_SYSTEM_HANDLE_INFORMATION\fP"
.br
.ti -1c
.RI "struct \fB_CLIENT_ID\fP"
.br
.ti -1c
.RI "struct \fB_IO_STATUS_BLOCK\fP"
.br
.ti -1c
.RI "struct \fB_UNICODE_STRING\fP"
.br
.ti -1c
.RI "struct \fB_OBJECT_ATTRIBUTES\fP"
.br
.ti -1c
.RI "struct \fB_INITIAL_TEB\fP"
.br
.ti -1c
.RI "struct \fB_AFD_CREATE_PACKET\fP"
.br
.ti -1c
.RI "struct \fB_AFD_BIND_DATA\fP"
.br
.ti -1c
.RI "struct \fB_AFD_LISTEN_DATA\fP"
.br
.ti -1c
.RI "struct \fB_AFD_ACCEPT_DATA\fP"
.br
.ti -1c
.RI "struct \fB_SOCKADDR_STORAGE\fP"
.br
.ti -1c
.RI "struct \fB_SOCK_SHARED_INFO\fP"
.br
.ti -1c
.RI "struct \fB_SOCKET_CONTEXT\fP"
.br
.ti -1c
.RI "struct \fB_AFD_CONNECT_INFO\fP"
.br
.ti -1c
.RI "struct \fB_AFD_WSABUF\fP"
.br
.ti -1c
.RI "struct \fB_AFD_RECV_INFO\fP"
.br
.ti -1c
.RI "struct \fB_AFD_RECV_INFO_UDP\fP"
.br
.ti -1c
.RI "struct \fB_AFD_SEND_INFO\fP"
.br
.ti -1c
.RI "struct \fB_AFD_SEND_INFO_UDP\fP"
.br
.ti -1c
.RI "struct \fB_DOMAIN_INFO\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBLOG_LEVEL_DEBUG\fP   0"
.br
.ti -1c
.RI "#define \fBLOG_LEVEL_INFO\fP   1"
.br
.ti -1c
.RI "#define \fBLOG_LEVEL_WARN\fP   2"
.br
.ti -1c
.RI "#define \fBLOG_LEVEL_ERROR\fP   3"
.br
.ti -1c
.RI "#define \fBCURRENT_LOG_LEVEL\fP   \fBLOG_LEVEL_DEBUG\fP"
.br
.ti -1c
.RI "#define \fBGET_CURRENT_TIME_STR\fP(buffer,  size)"
.br
.ti -1c
.RI "#define \fBLOG\fP(level,  level_str,  format, \&.\&.\&.)"
.br
.ti -1c
.RI "#define \fBLOG_DEBUG\fP(format, \&.\&.\&.)"
.br
.ti -1c
.RI "#define \fBLOG_INFO\fP(format, \&.\&.\&.)"
.br
.ti -1c
.RI "#define \fBLOG_WARN\fP(format, \&.\&.\&.)"
.br
.ti -1c
.RI "#define \fBLOG_ERROR\fP(format, \&.\&.\&.)"
.br
.ti -1c
.RI "#define \fBInitializeobject_attributes\fP(p,  n,  a,  r,  s)"
.br
.ti -1c
.RI "#define \fBNT_SUCCESS\fP(Status)"
.br
.ti -1c
.RI "#define \fBSystemHandleInformation\fP   0x10"
.br
.ti -1c
.RI "#define \fBSystemHandleInformationSize\fP   0x400000"
.br
.ti -1c
.RI "#define \fBFILE_SUPERSEDE\fP   0x0"
.br
.ti -1c
.RI "#define \fBFILE_OPEN\fP   0x1"
.br
.ti -1c
.RI "#define \fBFILE_CREATE\fP   0x2"
.br
.ti -1c
.RI "#define \fBFILE_OPEN_IF\fP   0x3"
.br
.ti -1c
.RI "#define \fBFILE_OVERWRITE\fP   0x4"
.br
.ti -1c
.RI "#define \fBFILE_OVERWRITE_IF\fP   0x5"
.br
.ti -1c
.RI "#define \fBFILE_MAXIMUM_DISPOSITION\fP   0x5"
.br
.ti -1c
.RI "#define \fBOBJ_INHERIT\fP   0x2L"
.br
.ti -1c
.RI "#define \fBOBJ_PERMANENT\fP   0x10L"
.br
.ti -1c
.RI "#define \fBOBJ_EXCLUSIVE\fP   0x20L"
.br
.ti -1c
.RI "#define \fBOBJ_CASE_INSENSITIVE\fP   0x40L"
.br
.ti -1c
.RI "#define \fBOBJ_OPENIF\fP   0x80L"
.br
.ti -1c
.RI "#define \fBOBJ_OPENLINK\fP   0x100L"
.br
.ti -1c
.RI "#define \fBOBJ_KERNEL_HANDLE\fP   0x200L"
.br
.ti -1c
.RI "#define \fBOBJ_FORCE_ACCESS_CHECK\fP   0x400L"
.br
.ti -1c
.RI "#define \fBOBJ_IGNORE_IMPERSONATED_DEVICEMAP\fP   0x800L"
.br
.ti -1c
.RI "#define \fBOBJ_DONT_REPARSE\fP   0x1000L"
.br
.ti -1c
.RI "#define \fBOBJ_VALID_ATTRIBUTES\fP   0x1FF2L"
.br
.ti -1c
.RI "#define \fBAFD_ENDPOINT_CONNECTIONLESS\fP   0x1"
.br
.ti -1c
.RI "#define \fBAFD_ENDPOINT_MESSAGE_ORIENTED\fP   0x10"
.br
.ti -1c
.RI "#define \fBAFD_ENDPOINT_RAW\fP   0x100"
.br
.ti -1c
.RI "#define \fBAFD_ENDPOINT_MULTIPOINT\fP   0x1000"
.br
.ti -1c
.RI "#define \fBAFD_ENDPOINT_C_ROOT\fP   0x10000"
.br
.ti -1c
.RI "#define \fBAFD_ENDPOINT_D_ROOT\fP   0x100000"
.br
.ti -1c
.RI "#define \fBTDI_RECEIVE_BROADCAST\fP   0x4"
.br
.ti -1c
.RI "#define \fBTDI_RECEIVE_MULTICAST\fP   0x8"
.br
.ti -1c
.RI "#define \fBTDI_RECEIVE_PARTIAL\fP   0x10"
.br
.ti -1c
.RI "#define \fBTDI_RECEIVE_NORMAL\fP   0x20"
.br
.ti -1c
.RI "#define \fBTDI_RECEIVE_EXPEDITED\fP   0x40"
.br
.ti -1c
.RI "#define \fBTDI_RECEIVE_PEEK\fP   0x80"
.br
.ti -1c
.RI "#define \fBTDI_RECEIVE_NO_RESPONSE_EXP\fP   0x100"
.br
.ti -1c
.RI "#define \fBTDI_RECEIVE_COPY_LOOKAHEAD\fP   0x200"
.br
.ti -1c
.RI "#define \fBTDI_RECEIVE_ENTIRE_MESSAGE\fP   0x400"
.br
.ti -1c
.RI "#define \fBTDI_RECEIVE_AT_DISPATCH_LEVEL\fP   0x800"
.br
.ti -1c
.RI "#define \fBTDI_RECEIVE_CONTROL_INFO\fP   0x1000"
.br
.ti -1c
.RI "#define \fBTDI_RECEIVE_FORCE_INDICATION\fP   0x2000"
.br
.ti -1c
.RI "#define \fBTDI_RECEIVE_NO_PUSH\fP   0x4000"
.br
.ti -1c
.RI "#define \fBMAX_PROTOCOL_CHAIN\fP   7"
.br
.ti -1c
.RI "#define \fBWSAPROTOCOL_LEN\fP   255"
.br
.ti -1c
.RI "#define \fBIOCTL_AFD_BIND\fP   0x12003"
.br
.ti -1c
.RI "#define \fBIOCTL_AFD_DOCONNECT\fP   0x12007"
.br
.ti -1c
.RI "#define \fBIOCTL_AFD_DOCONNECT_EX\fP   0x120c7"
.br
.ti -1c
.RI "#define \fBIOCTL_AFD_RECV\fP   0x12017"
.br
.ti -1c
.RI "#define \fBIOCTL_AFD_SEND\fP   0x1201F"
.br
.ti -1c
.RI "#define \fBIOCTL_AFD_SET_CONTEXT\fP   0x12047"
.br
.ti -1c
.RI "#define \fBIOCTL_AFD_GET_CONTEXT\fP   0x12043"
.br
.ti -1c
.RI "#define \fBSOCK_CONTEXT_BUF_SIZE\fP"
.br
.ti -1c
.RI "#define \fBSOCK_CONTEXT_ADDR_SIZE\fP   (sizeof(\fBSOCKADDR_STORAGE\fP))"
.br
.ti -1c
.RI "#define \fBINADDR_ANY\fP   0x00000000"
.br
.ti -1c
.RI "#define \fBINADDR_LOOPBACK\fP   0x7f000001"
.br
.ti -1c
.RI "#define \fBINADDR_BROADCAST\fP   0xffffffff"
.br
.ti -1c
.RI "#define \fBINADDR_NONE\fP   0xffffffff"
.br
.ti -1c
.RI "#define \fBDNS_SERVER\fP   '8\&.8\&.8\&.8'"
.br
.ti -1c
.RI "#define \fBDNS_PORT\fP   53"
.br
.ti -1c
.RI "#define \fBMAX_RECV_BYTES\fP   0x1000"
.br
.ti -1c
.RI "#define \fBMAX_SENT_BYTES\fP   0x1000"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef signed char \fBint8_t\fP"
.br
.ti -1c
.RI "typedef short \fBint16_t\fP"
.br
.ti -1c
.RI "typedef int \fBint32_t\fP"
.br
.ti -1c
.RI "typedef long long \fBint64_t\fP"
.br
.ti -1c
.RI "typedef unsigned char \fBuint8_t\fP"
.br
.ti -1c
.RI "typedef unsigned short \fBuint16_t\fP"
.br
.ti -1c
.RI "typedef unsigned int \fBuint32_t\fP"
.br
.ti -1c
.RI "typedef unsigned long long \fBuint64_t\fP"
.br
.ti -1c
.RI "typedef struct \fB_WSAPROTOCOLCHAIN\fP \fBWSAPROTOCOLCHAIN\fP"
.br
.ti -1c
.RI "typedef struct \fB_WSAPROTOCOLCHAIN\fP * \fBLPWSAPROTOCOLCHAIN\fP"
.br
.ti -1c
.RI "typedef struct \fB_WSAPROTOCOL_INFOW\fP \fBWSAPROTOCOL_INFOW\fP"
.br
.ti -1c
.RI "typedef struct \fB_WSAPROTOCOL_INFOW\fP * \fBLPWSAPROTOCOL_INFOW\fP"
.br
.ti -1c
.RI "typedef struct \fB_SYSTEM_HANDLE_TABLE_ENTRY_INFO\fP \fBSYSTEM_HANDLE_TABLE_ENTRY_INFO\fP"
.br
.ti -1c
.RI "typedef struct \fB_SYSTEM_HANDLE_TABLE_ENTRY_INFO\fP * \fBPSYSTEM_HANDLE_TABLE_ENTRY_INFO\fP"
.br
.ti -1c
.RI "typedef struct \fB_SYSTEM_HANDLE_INFORMATION\fP \fBSYSTEM_HANDLE_INFORMATION\fP"
.br
.ti -1c
.RI "typedef struct \fB_SYSTEM_HANDLE_INFORMATION\fP * \fBPSYSTEM_HANDLE_INFORMATION\fP"
.br
.ti -1c
.RI "typedef enum \fB_EVENT_TYPE\fP \fBEVENT_TYPE\fP"
.br
.ti -1c
.RI "typedef struct \fB_CLIENT_ID\fP \fBCLIENT_ID\fP"
.br
.ti -1c
.RI "typedef struct \fB_CLIENT_ID\fP * \fBPCLIENT_ID\fP"
.br
.ti -1c
.RI "typedef struct \fB_IO_STATUS_BLOCK\fP \fBIO_STATUS_BLOCK\fP"
.br
.ti -1c
.RI "typedef struct \fB_IO_STATUS_BLOCK\fP * \fBPIO_STATUS_BLOCK\fP"
.br
.ti -1c
.RI "typedef struct \fB_UNICODE_STRING\fP \fBUNICODE_STRING\fP"
.br
.ti -1c
.RI "typedef struct \fB_UNICODE_STRING\fP * \fBPUNICODE_STRING\fP"
.br
.ti -1c
.RI "typedef struct \fB_OBJECT_ATTRIBUTES\fP \fBOBJECT_ATTRIBUTES\fP"
.br
.ti -1c
.RI "typedef struct \fB_OBJECT_ATTRIBUTES\fP * \fBPOBJECT_ATTRIBUTES\fP"
.br
.ti -1c
.RI "typedef struct \fB_INITIAL_TEB\fP \fBINITIAL_TEB\fP"
.br
.ti -1c
.RI "typedef struct \fB_INITIAL_TEB\fP * \fBPINITIAL_TEB\fP"
.br
.ti -1c
.RI "typedef VOID(NTAPI * \fBPIO_APC_ROUTINE\fP) (PVOID ApcContext, \fBPIO_STATUS_BLOCK\fP IoStatusBlock, ULONG Reserved)"
.br
.ti -1c
.RI "typedef struct \fB_AFD_CREATE_PACKET\fP \fBAFD_CREATE_PACKET\fP"
.br
.ti -1c
.RI "typedef struct \fB_AFD_BIND_DATA\fP \fBAFD_BIND_DATA\fP"
.br
.ti -1c
.RI "typedef struct \fB_AFD_BIND_DATA\fP * \fBPAFD_BIND_DATA\fP"
.br
.ti -1c
.RI "typedef struct \fB_AFD_LISTEN_DATA\fP \fBAFD_LISTEN_DATA\fP"
.br
.ti -1c
.RI "typedef struct \fB_AFD_LISTEN_DATA\fP * \fBPAFD_LISTEN_DATA\fP"
.br
.ti -1c
.RI "typedef struct \fB_AFD_ACCEPT_DATA\fP \fBAFD_ACCEPT_DATA\fP"
.br
.ti -1c
.RI "typedef struct \fB_AFD_ACCEPT_DATA\fP * \fBPAFD_ACCEPT_DATA\fP"
.br
.ti -1c
.RI "typedef struct \fB_SOCKADDR_STORAGE\fP \fBSOCKADDR_STORAGE\fP"
.br
.ti -1c
.RI "typedef enum \fB_SOCKET_STATE\fP \fBSOCKET_STATE\fP"
.br
.ti -1c
.RI "typedef enum \fB_SOCKET_STATE\fP * \fBPSOCKET_STATE\fP"
.br
.ti -1c
.RI "typedef struct \fB_SOCK_SHARED_INFO\fP \fBSOCK_SHARED_INFO\fP"
.br
.ti -1c
.RI "typedef struct \fB_SOCK_SHARED_INFO\fP * \fBPSOCK_SHARED_INFO\fP"
.br
.ti -1c
.RI "typedef struct \fB_SOCKET_CONTEXT\fP \fBSOCKET_CONTEXT\fP"
.br
.ti -1c
.RI "typedef struct \fB_SOCKET_CONTEXT\fP * \fBPSOCKET_CONTEXT\fP"
.br
.ti -1c
.RI "typedef struct \fB_AFD_CONNECT_INFO\fP \fBAFD_CONNECT_INFO\fP"
.br
.ti -1c
.RI "typedef struct \fB_AFD_CONNECT_INFO\fP * \fBPAFD_CONNECT_INFO\fP"
.br
.ti -1c
.RI "typedef struct \fB_AFD_WSABUF\fP \fBAFD_WSABUF\fP"
.br
.ti -1c
.RI "typedef struct \fB_AFD_WSABUF\fP * \fBPAFD_WSABUF\fP"
.br
.ti -1c
.RI "typedef struct \fB_AFD_RECV_INFO\fP \fBAFD_RECV_INFO\fP"
.br
.ti -1c
.RI "typedef struct \fB_AFD_RECV_INFO\fP * \fBPAFD_RECV_INFO\fP"
.br
.ti -1c
.RI "typedef struct \fB_AFD_RECV_INFO_UDP\fP \fBAFD_RECV_INFO_UDP\fP"
.br
.ti -1c
.RI "typedef struct \fB_AFD_RECV_INFO_UDP\fP * \fBPAFD_RECV_INFO_UDP\fP"
.br
.ti -1c
.RI "typedef struct \fB_AFD_SEND_INFO\fP \fBAFD_SEND_INFO\fP"
.br
.ti -1c
.RI "typedef struct \fB_AFD_SEND_INFO\fP * \fBPAFD_SEND_INFO\fP"
.br
.ti -1c
.RI "typedef struct \fB_AFD_SEND_INFO_UDP\fP \fBAFD_SEND_INFO_UDP\fP"
.br
.ti -1c
.RI "typedef struct \fB_AFD_SEND_INFO_UDP\fP * \fBPAFD_SEND_INFO_UDP\fP"
.br
.ti -1c
.RI "typedef struct \fB_DOMAIN_INFO\fP \fBDOMAIN_INFO\fP"
.br
.ti -1c
.RI "typedef NTSTATUS(NTAPI * \fBNtClose_t\fP) (HANDLE Handle)"
.br
.ti -1c
.RI "typedef NTSTATUS(NTAPI * \fBNtCreateEvent_t\fP) (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, \fBPOBJECT_ATTRIBUTES\fP object_attributes, \fBEVENT_TYPE\fP EventType, BOOLEAN InitialState)"
.br
.ti -1c
.RI "typedef NTSTATUS(NTAPI * \fBNtDeviceIoControlFile_t\fP) (HANDLE FileHandle, HANDLE Event, \fBPIO_APC_ROUTINE\fP ApcRoutine, PVOID ApcContext, \fBPIO_STATUS_BLOCK\fP IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength)"
.br
.ti -1c
.RI "typedef NTSTATUS(NTAPI * \fBNtWaitForSingleObject_t\fP) (HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout)"
.br
.ti -1c
.RI "typedef NTSTATUS(NTAPI * \fBNtCreateFile_t\fP) (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, \fBPOBJECT_ATTRIBUTES\fP ObjectAttributes, \fBPIO_STATUS_BLOCK\fP IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength)"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fB_EVENT_TYPE\fP { \fBNotificationEvent\fP, \fBSynchronizationEvent\fP }"
.br
.ti -1c
.RI "enum \fB_SOCKET_STATE\fP { \fBSocketUndefined\fP = -1, \fBSocketOpen\fP, \fBSocketBound\fP, \fBSocketBoundUdp\fP, \fBSocketConnected\fP, \fBSocketClosed\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "NTSTATUS \fBnosa_dns_lookup\fP (HANDLE hSocket, const char *host, \fBDOMAIN_INFO\fP *outBuffer)"
.br
.ti -1c
.RI "int \fBis_digit\fP (char ch)"
.br
.ti -1c
.RI "int \fBis_hex_digit\fP (char ch)"
.br
.ti -1c
.RI "int \fBis_ipv4_address\fP (const char *host)"
.br
.ti -1c
.RI "int \fBis_ipv6_address\fP (const char *host)"
.br
.ti -1c
.RI "int \fBis_domain_name\fP (const char *host)"
.br
.ti -1c
.RI "ULONG \fBhtonl\fP (ULONG hostlong)"
.br
.ti -1c
.RI "USHORT \fBhtons\fP (USHORT netshort)"
.br
.ti -1c
.RI "USHORT \fBntohs\fP (USHORT netshort)"
.br
.ti -1c
.RI "ULONG \fBinet_addr\fP (PCSTR cp)"
.br
.ti -1c
.RI "ULONG \fBconvert_ip_to_htonl\fP (PCSTR ip_address)"
.br
.ti -1c
.RI "char * \fBconvert_htonl_to_ip_address\fP (unsigned long network_order_ip)"
.br
.ti -1c
.RI "unsigned char * \fBbuild_dns_query\fP (const char *domain, int *query_len)"
.br
.ti -1c
.RI "unsigned int \fBparse_dns_response\fP (unsigned char *response, int response_len)"
.br
.ti -1c
.RI "void \fBhexdump\fP (const void *buffer, size_t size)"
.br
.ti -1c
.RI "int \fBget_nt_functions\fP (void)"
.br
.ti -1c
.RI "NTSTATUS \fBget_ip_from_domain\fP (const char *host, char *ip_string)"
.br
.ti -1c
.RI "NTSTATUS \fBcreate_context\fP (DWORD addr_family, DWORD socket_type, DWORD socket_protocol, LPVOID out_buf)"
.br
.ti -1c
.RI "NTSTATUS \fBafd_create\fP (PHANDLE socket_handle, DWORD SocketType, DWORD socketProtocol)"
.br
.ti -1c
.RI "NTSTATUS \fBafd_bind\fP (HANDLE *socket_handle)"
.br
.ti -1c
.RI "NTSTATUS \fBafd_set_context\fP (HANDLE socket_handle, LPVOID input_buf)"
.br
.ti -1c
.RI "NTSTATUS \fBafd_get_context\fP (HANDLE socket_handle, LPVOID out_buf)"
.br
.ti -1c
.RI "NTSTATUS \fBafd_connect\fP (HANDLE *socket_handle, char *Address, int Port)"
.br
.ti -1c
.RI "NTSTATUS \fBafd_send\fP (HANDLE socket_handle, LPVOID buf, int query_len, BOOL is_dns_query)"
.br
.ti -1c
.RI "NTSTATUS \fBafd_recv\fP (HANDLE *socket_handle, LPVOID wsa_buffer)"
.br
.ti -1c
.RI "NTSTATUS \fBafd_close\fP (HANDLE Handle)"
.br
.ti -1c
.RI "NTSTATUS \fBnosa_connect\fP (HANDLE *hSocket, char *host, int port, const char *socketType)"
.br
.ti -1c
.RI "NTSTATUS \fBnosa_send\fP (HANDLE *hSocket, LPVOID packet_data, int packet_data_sz)"
.br
.ti -1c
.RI "NTSTATUS \fBnosa_recv\fP (HANDLE hSocket, LPVOID packet_data_received)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const GUID \fBGUID_NULL\fP"
.br
.ti -1c
.RI "\fBNtClose_t\fP \fBNtClose\fP"
.br
.ti -1c
.RI "\fBNtCreateEvent_t\fP \fBNtCreateEvent\fP"
.br
.ti -1c
.RI "\fBNtCreateFile_t\fP \fBNtCreateFile\fP"
.br
.ti -1c
.RI "\fBNtDeviceIoControlFile_t\fP \fBNtDeviceIoControlFile\fP"
.br
.ti -1c
.RI "\fBNtWaitForSingleObject_t\fP \fBNtWaitForSingleObject\fP"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define AFD_ENDPOINT_C_ROOT   0x10000"

.PP
Definition at line \fB125\fP of file \fBnosa\&.h\fP\&.
.SS "#define AFD_ENDPOINT_CONNECTIONLESS   0x1"

.PP
Definition at line \fB121\fP of file \fBnosa\&.h\fP\&.
.SS "#define AFD_ENDPOINT_D_ROOT   0x100000"

.PP
Definition at line \fB126\fP of file \fBnosa\&.h\fP\&.
.SS "#define AFD_ENDPOINT_MESSAGE_ORIENTED   0x10"

.PP
Definition at line \fB122\fP of file \fBnosa\&.h\fP\&.
.SS "#define AFD_ENDPOINT_MULTIPOINT   0x1000"

.PP
Definition at line \fB124\fP of file \fBnosa\&.h\fP\&.
.SS "#define AFD_ENDPOINT_RAW   0x100"

.PP
Definition at line \fB123\fP of file \fBnosa\&.h\fP\&.
.SS "#define CURRENT_LOG_LEVEL   \fBLOG_LEVEL_DEBUG\fP"

.PP
Definition at line \fB15\fP of file \fBnosa\&.h\fP\&.
.SS "#define DNS_PORT   53"

.PP
Definition at line \fB167\fP of file \fBnosa\&.h\fP\&.
.SS "#define DNS_SERVER   '8\&.8\&.8\&.8'"

.PP
Definition at line \fB166\fP of file \fBnosa\&.h\fP\&.
.SS "#define FILE_CREATE   0x2"

.PP
Definition at line \fB102\fP of file \fBnosa\&.h\fP\&.
.SS "#define FILE_MAXIMUM_DISPOSITION   0x5"

.PP
Definition at line \fB106\fP of file \fBnosa\&.h\fP\&.
.SS "#define FILE_OPEN   0x1"

.PP
Definition at line \fB101\fP of file \fBnosa\&.h\fP\&.
.SS "#define FILE_OPEN_IF   0x3"

.PP
Definition at line \fB103\fP of file \fBnosa\&.h\fP\&.
.SS "#define FILE_OVERWRITE   0x4"

.PP
Definition at line \fB104\fP of file \fBnosa\&.h\fP\&.
.SS "#define FILE_OVERWRITE_IF   0x5"

.PP
Definition at line \fB105\fP of file \fBnosa\&.h\fP\&.
.SS "#define FILE_SUPERSEDE   0x0"

.PP
Definition at line \fB100\fP of file \fBnosa\&.h\fP\&.
.SS "#define GET_CURRENT_TIME_STR( buffer,  size)"
\fBValue:\fP
.nf
    do { \\
        SYSTEMTIME st; \\
        GetSystemTime(&st); \\
        snprintf(buffer, size, "%02d:%02d:%02d", \\
                 st\&.wHour, st\&.wMinute, st\&.wSecond); \\
    } while (0)
.PP
.fi

.PP
Definition at line \fB19\fP of file \fBnosa\&.h\fP\&.
.SS "#define INADDR_ANY   0x00000000"

.PP
Definition at line \fB161\fP of file \fBnosa\&.h\fP\&.
.SS "#define INADDR_BROADCAST   0xffffffff"

.PP
Definition at line \fB163\fP of file \fBnosa\&.h\fP\&.
.SS "#define INADDR_LOOPBACK   0x7f000001"

.PP
Definition at line \fB162\fP of file \fBnosa\&.h\fP\&.
.SS "#define INADDR_NONE   0xffffffff"

.PP
Definition at line \fB164\fP of file \fBnosa\&.h\fP\&.
.SS "#define Initializeobject_attributes( p,  n,  a,  r,  s)"
\fBValue:\fP
.nf
    { \\
    (p)\->Length = sizeof(OBJECT_ATTRIBUTES);        \\
    (p)\->RootDirectory = r;                         \\
    (p)\->Attributes = a;                            \\
    (p)\->ObjectName = n;                            \\
    (p)\->SecurityDescriptor = s;                    \\
    (p)\->SecurityQualityOfService = NULL;           \\
}
.PP
.fi

.PP
Definition at line \fB47\fP of file \fBnosa\&.h\fP\&.
.SS "#define IOCTL_AFD_BIND   0x12003"

.PP
Definition at line \fB145\fP of file \fBnosa\&.h\fP\&.
.SS "#define IOCTL_AFD_DOCONNECT   0x12007"

.PP
Definition at line \fB146\fP of file \fBnosa\&.h\fP\&.
.SS "#define IOCTL_AFD_DOCONNECT_EX   0x120c7"

.PP
Definition at line \fB147\fP of file \fBnosa\&.h\fP\&.
.SS "#define IOCTL_AFD_GET_CONTEXT   0x12043"

.PP
Definition at line \fB152\fP of file \fBnosa\&.h\fP\&.
.SS "#define IOCTL_AFD_RECV   0x12017"

.PP
Definition at line \fB148\fP of file \fBnosa\&.h\fP\&.
.SS "#define IOCTL_AFD_SEND   0x1201F"

.PP
Definition at line \fB149\fP of file \fBnosa\&.h\fP\&.
.SS "#define IOCTL_AFD_SET_CONTEXT   0x12047"

.PP
Definition at line \fB151\fP of file \fBnosa\&.h\fP\&.
.SS "#define LOG( level,  level_str,  format,  \&.\&.\&.)"
\fBValue:\fP
.nf
    do { \\
        if (level >= CURRENT_LOG_LEVEL) { \\
            char time_str[16]; \\
            char *filename = strrchr(__FILE__, '\\\\'); \\
            GET_CURRENT_TIME_STR(time_str, sizeof(time_str)); \\
            fprintf(stderr, "[%s] %s:%s:%d: " format "\\n\\n", \\
                    time_str, level_str, filename, __LINE__, ##__VA_ARGS__); \\
        } \\
    } while (0)
.PP
.fi

.PP
Definition at line \fB28\fP of file \fBnosa\&.h\fP\&.
.SS "#define LOG_DEBUG( format,  \&.\&.\&.)"
\fBValue:\fP
.nf
LOG(LOG_LEVEL_DEBUG, "DEBUG", format, ##__VA_ARGS__)
.PP
.fi

.PP
Definition at line \fB40\fP of file \fBnosa\&.h\fP\&.
.SS "#define LOG_ERROR( format,  \&.\&.\&.)"
\fBValue:\fP
.nf
LOG(LOG_LEVEL_ERROR, "ERROR", format, ##__VA_ARGS__)
.PP
.fi

.PP
Definition at line \fB43\fP of file \fBnosa\&.h\fP\&.
.SS "#define LOG_INFO( format,  \&.\&.\&.)"
\fBValue:\fP
.nf
LOG(LOG_LEVEL_INFO,  "INFO",  format, ##__VA_ARGS__)
.PP
.fi

.PP
Definition at line \fB41\fP of file \fBnosa\&.h\fP\&.
.SS "#define LOG_LEVEL_DEBUG   0"

.PP
Definition at line \fB8\fP of file \fBnosa\&.h\fP\&.
.SS "#define LOG_LEVEL_ERROR   3"

.PP
Definition at line \fB11\fP of file \fBnosa\&.h\fP\&.
.SS "#define LOG_LEVEL_INFO   1"

.PP
Definition at line \fB9\fP of file \fBnosa\&.h\fP\&.
.SS "#define LOG_LEVEL_WARN   2"

.PP
Definition at line \fB10\fP of file \fBnosa\&.h\fP\&.
.SS "#define LOG_WARN( format,  \&.\&.\&.)"
\fBValue:\fP
.nf
LOG(LOG_LEVEL_WARN,  "WARN",  format, ##__VA_ARGS__)
.PP
.fi

.PP
Definition at line \fB42\fP of file \fBnosa\&.h\fP\&.
.SS "#define MAX_PROTOCOL_CHAIN   7"

.PP
Definition at line \fB142\fP of file \fBnosa\&.h\fP\&.
.SS "#define MAX_RECV_BYTES   0x1000"

.PP
Definition at line \fB169\fP of file \fBnosa\&.h\fP\&.
.SS "#define MAX_SENT_BYTES   0x1000"

.PP
Definition at line \fB170\fP of file \fBnosa\&.h\fP\&.
.SS "#define NT_SUCCESS( Status)"
\fBValue:\fP
.nf
(((NTSTATUS)(Status)) >= 0)
.PP
.fi

.PP
Definition at line \fB95\fP of file \fBnosa\&.h\fP\&.
.SS "#define OBJ_CASE_INSENSITIVE   0x40L"

.PP
Definition at line \fB111\fP of file \fBnosa\&.h\fP\&.
.SS "#define OBJ_DONT_REPARSE   0x1000L"

.PP
Definition at line \fB117\fP of file \fBnosa\&.h\fP\&.
.SS "#define OBJ_EXCLUSIVE   0x20L"

.PP
Definition at line \fB110\fP of file \fBnosa\&.h\fP\&.
.SS "#define OBJ_FORCE_ACCESS_CHECK   0x400L"

.PP
Definition at line \fB115\fP of file \fBnosa\&.h\fP\&.
.SS "#define OBJ_IGNORE_IMPERSONATED_DEVICEMAP   0x800L"

.PP
Definition at line \fB116\fP of file \fBnosa\&.h\fP\&.
.SS "#define OBJ_INHERIT   0x2L"

.PP
Definition at line \fB108\fP of file \fBnosa\&.h\fP\&.
.SS "#define OBJ_KERNEL_HANDLE   0x200L"

.PP
Definition at line \fB114\fP of file \fBnosa\&.h\fP\&.
.SS "#define OBJ_OPENIF   0x80L"

.PP
Definition at line \fB112\fP of file \fBnosa\&.h\fP\&.
.SS "#define OBJ_OPENLINK   0x100L"

.PP
Definition at line \fB113\fP of file \fBnosa\&.h\fP\&.
.SS "#define OBJ_PERMANENT   0x10L"

.PP
Definition at line \fB109\fP of file \fBnosa\&.h\fP\&.
.SS "#define OBJ_VALID_ATTRIBUTES   0x1FF2L"

.PP
Definition at line \fB118\fP of file \fBnosa\&.h\fP\&.
.SS "#define SOCK_CONTEXT_ADDR_SIZE   (sizeof(\fBSOCKADDR_STORAGE\fP))"

.PP
Definition at line \fB159\fP of file \fBnosa\&.h\fP\&.
.SS "#define SOCK_CONTEXT_BUF_SIZE"
\fBValue:\fP
.nf
                                ( sizeof(SOCK_SHARED_INFO) + \\
                                sizeof(GUID)+ \\
                                sizeof(PVOID) + 8 + \\
                                (2 * sizeof(SOCKADDR_STORAGE)))
.PP
.fi

.PP
Definition at line \fB154\fP of file \fBnosa\&.h\fP\&.
.SS "#define SystemHandleInformation   0x10"

.PP
Definition at line \fB97\fP of file \fBnosa\&.h\fP\&.
.SS "#define SystemHandleInformationSize   0x400000"

.PP
Definition at line \fB98\fP of file \fBnosa\&.h\fP\&.
.SS "#define TDI_RECEIVE_AT_DISPATCH_LEVEL   0x800"

.PP
Definition at line \fB137\fP of file \fBnosa\&.h\fP\&.
.SS "#define TDI_RECEIVE_BROADCAST   0x4"

.PP
Definition at line \fB128\fP of file \fBnosa\&.h\fP\&.
.SS "#define TDI_RECEIVE_CONTROL_INFO   0x1000"

.PP
Definition at line \fB138\fP of file \fBnosa\&.h\fP\&.
.SS "#define TDI_RECEIVE_COPY_LOOKAHEAD   0x200"

.PP
Definition at line \fB135\fP of file \fBnosa\&.h\fP\&.
.SS "#define TDI_RECEIVE_ENTIRE_MESSAGE   0x400"

.PP
Definition at line \fB136\fP of file \fBnosa\&.h\fP\&.
.SS "#define TDI_RECEIVE_EXPEDITED   0x40"

.PP
Definition at line \fB132\fP of file \fBnosa\&.h\fP\&.
.SS "#define TDI_RECEIVE_FORCE_INDICATION   0x2000"

.PP
Definition at line \fB139\fP of file \fBnosa\&.h\fP\&.
.SS "#define TDI_RECEIVE_MULTICAST   0x8"

.PP
Definition at line \fB129\fP of file \fBnosa\&.h\fP\&.
.SS "#define TDI_RECEIVE_NO_PUSH   0x4000"

.PP
Definition at line \fB140\fP of file \fBnosa\&.h\fP\&.
.SS "#define TDI_RECEIVE_NO_RESPONSE_EXP   0x100"

.PP
Definition at line \fB134\fP of file \fBnosa\&.h\fP\&.
.SS "#define TDI_RECEIVE_NORMAL   0x20"

.PP
Definition at line \fB131\fP of file \fBnosa\&.h\fP\&.
.SS "#define TDI_RECEIVE_PARTIAL   0x10"

.PP
Definition at line \fB130\fP of file \fBnosa\&.h\fP\&.
.SS "#define TDI_RECEIVE_PEEK   0x80"

.PP
Definition at line \fB133\fP of file \fBnosa\&.h\fP\&.
.SS "#define WSAPROTOCOL_LEN   255"

.PP
Definition at line \fB143\fP of file \fBnosa\&.h\fP\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fB_AFD_ACCEPT_DATA\fP \fBAFD_ACCEPT_DATA\fP"
Structure representing data for accepting connections in the AFD (Ancillary Function Driver)\&. 
.SS "typedef struct \fB_AFD_BIND_DATA\fP \fBAFD_BIND_DATA\fP"
Structure representing AFD bind data\&. 
.SS "typedef struct \fB_AFD_CONNECT_INFO\fP \fBAFD_CONNECT_INFO\fP"
Structure representing AFD (Ancillary Function Driver) connection information\&. 
.SS "typedef struct \fB_AFD_CREATE_PACKET\fP \fBAFD_CREATE_PACKET\fP"
Structure representing an AFD_CREATE_PACKET\&.

.PP
This structure contains information related to creating an AFD packet\&. It includes fields for various parameters such as NextEntryOffset, Flags, EaNameLength, EaValueLength, EaName, EndpointFlags, GroupID, AddressFamily, SocketType, Protocol, SizeOfTransportName, and TransportName\&. 
.SS "typedef struct \fB_AFD_LISTEN_DATA\fP \fBAFD_LISTEN_DATA\fP"
Structure representing AFD listen data\&. 
.SS "typedef struct \fB_AFD_RECV_INFO\fP \fBAFD_RECV_INFO\fP"
Structure representing information for AFD receive operation\&. 
.SS "typedef struct \fB_AFD_RECV_INFO_UDP\fP \fBAFD_RECV_INFO_UDP\fP"
Structure representing information for UDP receive operation in AFD\&. 
.SS "typedef struct \fB_AFD_SEND_INFO\fP \fBAFD_SEND_INFO\fP"
Structure representing information for sending data using AFD\&. 
.SS "typedef struct \fB_AFD_SEND_INFO_UDP\fP \fBAFD_SEND_INFO_UDP\fP"
Structure representing information for sending data over UDP using AFD\&. 
.SS "typedef struct \fB_AFD_WSABUF\fP \fBAFD_WSABUF\fP"
Structure representing a buffer and its length for Winsock operations\&. 
.SS "typedef struct \fB_CLIENT_ID\fP \fBCLIENT_ID\fP"

.SS "typedef struct \fB_DOMAIN_INFO\fP \fBDOMAIN_INFO\fP"
Structure representing information for further DNS query lookup\&. 
.SS "typedef enum \fB_EVENT_TYPE\fP \fBEVENT_TYPE\fP"

.SS "typedef struct \fB_INITIAL_TEB\fP \fBINITIAL_TEB\fP"

.SS "typedef short \fBint16_t\fP"

.PP
Definition at line \fB61\fP of file \fBnosa\&.h\fP\&.
.SS "typedef int \fBint32_t\fP"

.PP
Definition at line \fB62\fP of file \fBnosa\&.h\fP\&.
.SS "typedef long long \fBint64_t\fP"

.PP
Definition at line \fB63\fP of file \fBnosa\&.h\fP\&.
.SS "typedef signed char \fBint8_t\fP"

.PP
Definition at line \fB60\fP of file \fBnosa\&.h\fP\&.
.SS "typedef struct \fB_IO_STATUS_BLOCK\fP \fBIO_STATUS_BLOCK\fP"

.SS "typedef struct \fB_WSAPROTOCOL_INFOW\fP * \fBLPWSAPROTOCOL_INFOW\fP"

.SS "typedef struct \fB_WSAPROTOCOLCHAIN\fP * \fBLPWSAPROTOCOLCHAIN\fP"

.SS "typedef NTSTATUS(NTAPI * NtClose_t) (HANDLE Handle)"

.PP
Definition at line \fB493\fP of file \fBnosa\&.h\fP\&.
.SS "typedef NTSTATUS(NTAPI * NtCreateEvent_t) (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, \fBPOBJECT_ATTRIBUTES\fP object_attributes, \fBEVENT_TYPE\fP EventType, BOOLEAN InitialState)"

.PP
Definition at line \fB494\fP of file \fBnosa\&.h\fP\&.
.SS "typedef NTSTATUS(NTAPI * NtCreateFile_t) (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, \fBPOBJECT_ATTRIBUTES\fP ObjectAttributes, \fBPIO_STATUS_BLOCK\fP IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength)"

.PP
Definition at line \fB500\fP of file \fBnosa\&.h\fP\&.
.SS "typedef NTSTATUS(NTAPI * NtDeviceIoControlFile_t) (HANDLE FileHandle, HANDLE Event, \fBPIO_APC_ROUTINE\fP ApcRoutine, PVOID ApcContext, \fBPIO_STATUS_BLOCK\fP IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength)"

.PP
Definition at line \fB496\fP of file \fBnosa\&.h\fP\&.
.SS "typedef NTSTATUS(NTAPI * NtWaitForSingleObject_t) (HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout)"

.PP
Definition at line \fB499\fP of file \fBnosa\&.h\fP\&.
.SS "typedef struct \fB_OBJECT_ATTRIBUTES\fP \fBOBJECT_ATTRIBUTES\fP"

.SS "typedef struct \fB_AFD_ACCEPT_DATA\fP * \fBPAFD_ACCEPT_DATA\fP"

.SS "typedef struct \fB_AFD_BIND_DATA\fP * \fBPAFD_BIND_DATA\fP"

.SS "typedef struct \fB_AFD_CONNECT_INFO\fP * \fBPAFD_CONNECT_INFO\fP"

.SS "typedef struct \fB_AFD_LISTEN_DATA\fP * \fBPAFD_LISTEN_DATA\fP"

.SS "typedef struct \fB_AFD_RECV_INFO\fP * \fBPAFD_RECV_INFO\fP"

.SS "typedef struct \fB_AFD_RECV_INFO_UDP\fP * \fBPAFD_RECV_INFO_UDP\fP"

.SS "typedef struct \fB_AFD_SEND_INFO\fP * \fBPAFD_SEND_INFO\fP"

.SS "typedef struct \fB_AFD_SEND_INFO_UDP\fP * \fBPAFD_SEND_INFO_UDP\fP"

.SS "typedef struct \fB_AFD_WSABUF\fP * \fBPAFD_WSABUF\fP"

.SS "typedef struct \fB_CLIENT_ID\fP * \fBPCLIENT_ID\fP"

.SS "typedef struct \fB_INITIAL_TEB\fP * \fBPINITIAL_TEB\fP"

.SS "typedef VOID(NTAPI * PIO_APC_ROUTINE) (PVOID ApcContext, \fBPIO_STATUS_BLOCK\fP IoStatusBlock, ULONG Reserved)"

.PP
Definition at line \fB271\fP of file \fBnosa\&.h\fP\&.
.SS "typedef struct \fB_IO_STATUS_BLOCK\fP * \fBPIO_STATUS_BLOCK\fP"

.SS "typedef struct \fB_OBJECT_ATTRIBUTES\fP * \fBPOBJECT_ATTRIBUTES\fP"

.SS "typedef struct \fB_SOCK_SHARED_INFO\fP * \fBPSOCK_SHARED_INFO\fP"

.SS "typedef struct \fB_SOCKET_CONTEXT\fP * \fBPSOCKET_CONTEXT\fP"

.SS "typedef enum \fB_SOCKET_STATE\fP * \fBPSOCKET_STATE\fP"

.SS "typedef struct \fB_SYSTEM_HANDLE_INFORMATION\fP * \fBPSYSTEM_HANDLE_INFORMATION\fP"

.SS "typedef struct \fB_SYSTEM_HANDLE_TABLE_ENTRY_INFO\fP * \fBPSYSTEM_HANDLE_TABLE_ENTRY_INFO\fP"

.SS "typedef struct \fB_UNICODE_STRING\fP * \fBPUNICODE_STRING\fP"

.SS "typedef struct \fB_SOCK_SHARED_INFO\fP \fBSOCK_SHARED_INFO\fP"
Structure representing AFD (Ancillary Function Driver) shared informations\&. 
.SS "typedef struct \fB_SOCKADDR_STORAGE\fP \fBSOCKADDR_STORAGE\fP"

.SS "typedef struct \fB_SOCKET_CONTEXT\fP \fBSOCKET_CONTEXT\fP"
Structure representing AFD (Ancillary Function Driver) current socket-context informations\&. 
.SS "typedef enum \fB_SOCKET_STATE\fP \fBSOCKET_STATE\fP"
Structure representing AFD (Ancillary Function Driver) actual socket state\&. 
.SS "typedef struct \fB_SYSTEM_HANDLE_INFORMATION\fP \fBSYSTEM_HANDLE_INFORMATION\fP"

.SS "typedef struct \fB_SYSTEM_HANDLE_TABLE_ENTRY_INFO\fP \fBSYSTEM_HANDLE_TABLE_ENTRY_INFO\fP"

.SS "typedef unsigned short \fBuint16_t\fP"

.PP
Definition at line \fB65\fP of file \fBnosa\&.h\fP\&.
.SS "typedef unsigned int \fBuint32_t\fP"

.PP
Definition at line \fB66\fP of file \fBnosa\&.h\fP\&.
.SS "typedef unsigned long long \fBuint64_t\fP"

.PP
Definition at line \fB67\fP of file \fBnosa\&.h\fP\&.
.SS "typedef unsigned char \fBuint8_t\fP"

.PP
Definition at line \fB64\fP of file \fBnosa\&.h\fP\&.
.SS "typedef struct \fB_UNICODE_STRING\fP \fBUNICODE_STRING\fP"

.SS "typedef struct \fB_WSAPROTOCOL_INFOW\fP \fBWSAPROTOCOL_INFOW\fP"

.SS "typedef struct \fB_WSAPROTOCOLCHAIN\fP \fBWSAPROTOCOLCHAIN\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fB_EVENT_TYPE\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BINotificationEvent \fP
.TP
\f(BISynchronizationEvent \fP
.PP
Definition at line \fB224\fP of file \fBnosa\&.h\fP\&.
.SS "enum \fB_SOCKET_STATE\fP"
Structure representing AFD (Ancillary Function Driver) actual socket state\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BISocketUndefined \fP
.TP
\f(BISocketOpen \fP
.TP
\f(BISocketBound \fP
.TP
\f(BISocketBoundUdp \fP
.TP
\f(BISocketConnected \fP
.TP
\f(BISocketClosed \fP
.PP
Definition at line \fB342\fP of file \fBnosa\&.h\fP\&.
.SH "Function Documentation"
.PP 
.SS "NTSTATUS afd_bind (HANDLE * socket_handle)"
Binds a socket handle using the AFD (Ancillary Function Driver) interface\&.

.PP
\fBParameters\fP
.RS 4
\fIsocket_handle\fP Pointer to the socket handle to bind\&.
.RE
.PP
\fBReturns\fP
.RS 4
NTSTATUS The status of the AFD bind operation\&. 
.RE
.PP

.PP
Definition at line \fB1194\fP of file \fBnosa\&.h\fP\&.
.SS "NTSTATUS afd_close (HANDLE Handle)"
Closes an AFD handle\&.

.PP
\fBParameters\fP
.RS 4
\fIHandle\fP The handle to be closed\&.
.RE
.PP
\fBReturns\fP
.RS 4
NTSTATUS indicating the result of the close operation\&. 
.RE
.PP

.PP
Definition at line \fB1559\fP of file \fBnosa\&.h\fP\&.
.SS "NTSTATUS afd_connect (HANDLE * socket_handle, char * Address, int Port)"
Establishes a connection to a specified address and port using AFD (Ancillary Function Driver)\&.

.PP
\fBParameters\fP
.RS 4
\fIsocket_handle\fP Pointer to the socket handle\&. 
.br
\fIAddress\fP The address to connect to\&. 
.br
\fIPort\fP The port number to connect to\&.
.RE
.PP
\fBReturns\fP
.RS 4
The status of the connection attempt\&. 
.RE
.PP

.PP
Definition at line \fB1356\fP of file \fBnosa\&.h\fP\&.
.SS "NTSTATUS afd_create (PHANDLE socket_handle, DWORD SocketType, DWORD socketProtocol)"
Creates an AFD socket with the specified socket type\&.

.PP
\fBParameters\fP
.RS 4
\fIsocket_handle\fP Pointer to a handle that will receive the socket handle\&. 
.br
\fISocketType\fP The type of the socket to be created\&. 
.br
\fIsocketProtocol\fP The protocol of the socket to be created\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The status of the AFD socket creation operation\&. 
.RE
.PP

.PP
Definition at line \fB1129\fP of file \fBnosa\&.h\fP\&.
.SS "NTSTATUS afd_get_context (HANDLE socket_handle, LPVOID out_buf)"
Retrieves the context for a given socket using the AFD (Ancillary Function Driver) subsystem\&.

.PP
\fBParameters\fP
.RS 4
\fIsocket_handle\fP - The handle to the socket for which the context is to be retrieved\&. 
.br
\fIout_buf\fP - A pointer to the buffer where the retrieved context data will be stored\&.
.RE
.PP
\fBReturns\fP
.RS 4
NTSTATUS - The status code of the operation\&. If successful, the status will indicate success; otherwise, it will provide an error code\&. 
.RE
.PP

.PP
Definition at line \fB1307\fP of file \fBnosa\&.h\fP\&.
.SS "NTSTATUS afd_recv (HANDLE * socket_handle, LPVOID wsa_buffer)"
Receives data from a socket using the Windows AFD API\&.

.PP
\fBParameters\fP
.RS 4
\fIsocket_handle\fP A pointer to the handle of the socket\&. 
.br
\fIwsa_buffer\fP A pointer to the buffer to store the received data\&.
.RE
.PP
\fBReturns\fP
.RS 4
The status of the operation\&. 
.RE
.PP

.PP
Definition at line \fB1497\fP of file \fBnosa\&.h\fP\&.
.SS "NTSTATUS afd_send (HANDLE socket_handle, LPVOID buf, int query_len, BOOL is_dns_query)"
Sends a buffer over a specified socket handle using the AFD (Ancillary Function Driver) interface\&.

.PP
\fBParameters\fP
.RS 4
\fIsocket_handle\fP The handle to the socket for sending the data\&. 
.br
\fIbuf\fP The buffer containing the data to be sent\&. 
.br
\fIquery_len\fP The length of the data buffer\&. 
.br
\fIis_dns_query\fP A boolean flag indicating if the data is a DNS query\&.
.RE
.PP
\fBReturns\fP
.RS 4
The NTSTATUS of the send operation\&. 
.RE
.PP

.PP
Definition at line \fB1419\fP of file \fBnosa\&.h\fP\&.
.SS "NTSTATUS afd_set_context (HANDLE socket_handle, LPVOID input_buf)"
Sets the context for a given socket using the AFD (Ancillary Function Driver) subsystem\&.

.PP
\fBParameters\fP
.RS 4
\fIsocket_handle\fP - The handle to the socket for which the context is to be set\&. 
.br
\fIinput_buf\fP - A pointer to the buffer containing the context data to be set\&.
.RE
.PP
\fBReturns\fP
.RS 4
NTSTATUS - The status code of the operation\&. If successful, the status will indicate success; otherwise, it will provide an error code\&. 
.RE
.PP

.PP
Definition at line \fB1258\fP of file \fBnosa\&.h\fP\&.
.SS "unsigned char * build_dns_query (const char * domain, int * query_len)"
Builds a DNS query for the given domain\&.

.PP
\fBParameters\fP
.RS 4
\fIdomain\fP The domain name to query\&. 
.br
\fIquery_len\fP Pointer to store the length of the query\&.
.RE
.PP
\fBReturns\fP
.RS 4
A pointer to the constructed DNS query\&. 
.RE
.PP

.PP
Definition at line \fB836\fP of file \fBnosa\&.h\fP\&.
.SS "char * convert_htonl_to_ip_address (unsigned long network_order_ip)"
Converts a 32-bit network-order IP address to a human-readable IP address format\&.

.PP
\fBParameters\fP
.RS 4
\fInetwork_order_ip\fP The 32-bit network-order IP address to convert\&.
.RE
.PP
\fBReturns\fP
.RS 4
A pointer to a static character array containing the human-readable IP address\&. 
.RE
.PP

.PP
Definition at line \fB814\fP of file \fBnosa\&.h\fP\&.
.SS "ULONG convert_ip_to_htonl (PCSTR ip_address)"
Converts an IP address from string format to network byte order (big-endian)\&.

.PP
\fBParameters\fP
.RS 4
\fIip_address\fP The IP address in string format\&.
.RE
.PP
\fBReturns\fP
.RS 4
The IP address in network byte order\&. 
.RE
.PP

.PP
Definition at line \fB777\fP of file \fBnosa\&.h\fP\&.
.SS "NTSTATUS create_context (DWORD addr_family, DWORD socket_type, DWORD socket_protocol, LPVOID out_buf)"
Initializes a socket context structure with the specified address family and stores it in the provided output buffer\&.

.PP
\fBParameters\fP
.RS 4
\fIaddr_family\fP - The address family (e\&.g\&., AF_INET for IPv4) to be used for the socket context\&. 
.br
\fIsocket_type\fP The type of the socket to be created\&. 
.br
\fIsocket_protocol\fP The protocol of the socket to be created\&. 
.br
\fIout_buf\fP - A pointer to the buffer where the socket context will be stored\&. 
.RE
.PP
\fBReturns\fP
.RS 4
NTSTATUS - The status code of the operation\&. Currently, it always returns STATUS_SUCCESS\&. 
.RE
.PP

.PP
Definition at line \fB1059\fP of file \fBnosa\&.h\fP\&.
.SS "NTSTATUS get_ip_from_domain (const char * host, char * ip_string)"
Retrieves the IP address corresponding to a given domain name\&.

.PP
This function lookups the domain name to an IP address using DNS resolution\&.

.PP
\fBParameters\fP
.RS 4
\fIhost\fP The domain name to lookup\&. 
.br
\fIip_string\fP The buffer to store the resulting IP address string\&.
.RE
.PP
\fBReturns\fP
.RS 4
The status of the IP address retrieval operation\&. 
.RE
.PP

.PP
Definition at line \fB1021\fP of file \fBnosa\&.h\fP\&.
.SS "int get_nt_functions (void )"
Retrieves the number of functions from ntdll\&.dll that are required for the application\&.

.PP
\fBReturns\fP
.RS 4
The number of functions retrieved from ntdll\&.dll\&. \\ Returns -1 if loading ntdll\&.dll fails or if any of the required functions are not found\&. 
.RE
.PP

.PP
Definition at line \fB983\fP of file \fBnosa\&.h\fP\&.
.SS "void hexdump (const void * buffer, size_t size)"
Displays a hex dump of the given buffer\&.

.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP Pointer to the buffer to be dumped\&. 
.br
\fIsize\fP Size of the buffer in bytes\&.
.RE
.PP
\fBReturns\fP
.RS 4
None 
.RE
.PP

.PP
Definition at line \fB942\fP of file \fBnosa\&.h\fP\&.
.SS "ULONG htonl (ULONG hostlong)"
Converts a 32-bit unsigned long integer from host byte order to network byte order\&.

.PP
\fBParameters\fP
.RS 4
\fIhostlong\fP The value to be converted from host byte order to network byte order\&.
.RE
.PP
\fBReturns\fP
.RS 4
The converted value in network byte order\&. 
.RE
.PP

.PP
Definition at line \fB642\fP of file \fBnosa\&.h\fP\&.
.SS "USHORT htons (USHORT netshort)"
Converts a 16-bit number from host to network byte order\&.

.PP
\fBParameters\fP
.RS 4
\fInetshort\fP The 16-bit number in host byte order\&.
.RE
.PP
\fBReturns\fP
.RS 4
The 16-bit number in network byte order\&. 
.RE
.PP

.PP
Definition at line \fB657\fP of file \fBnosa\&.h\fP\&.
.SS "ULONG inet_addr (PCSTR cp)"
Converts a string containing an IPv4 address in dotted-decimal notation to a ULONG value in network byte order\&.

.PP
\fBParameters\fP
.RS 4
\fIcp\fP A pointer to a null-terminated string representing the IPv4 address\&.
.RE
.PP
\fBReturns\fP
.RS 4
The ULONG value representing the IPv4 address in network byte order\&. 
.RE
.PP

.PP
Definition at line \fB684\fP of file \fBnosa\&.h\fP\&.
.SS "int is_digit (char ch)"
Check if a character is a digit\&.

.PP
\fBParameters\fP
.RS 4
\fIch\fP The character to be checked\&.
.RE
.PP
\fBReturns\fP
.RS 4
1 if the character is a digit, 0 otherwise\&. 
.RE
.PP

.PP
Definition at line \fB520\fP of file \fBnosa\&.h\fP\&.
.SS "int is_domain_name (const char * host)"
Checks if the given input is a valid domain name\&.

.PP
\fBParameters\fP
.RS 4
\fIhost\fP The input string to be checked\&.
.RE
.PP
\fBReturns\fP
.RS 4
1 if the input is a valid domain name, 0 otherwise\&. 
.RE
.PP

.PP
Definition at line \fB610\fP of file \fBnosa\&.h\fP\&.
.SS "int is_hex_digit (char ch)"
Checks if a character is a hexadecimal digit\&.

.PP
\fBParameters\fP
.RS 4
\fIch\fP The character to be checked\&.
.RE
.PP
\fBReturns\fP
.RS 4
1 if the character is a hexadecimal digit, 0 otherwise\&. 
.RE
.PP

.PP
Definition at line \fB532\fP of file \fBnosa\&.h\fP\&.
.SS "int is_ipv4_address (const char * host)"

.PP
Definition at line \fB538\fP of file \fBnosa\&.h\fP\&.
.SS "int is_ipv6_address (const char * host)"
Checks if the given string is a valid IPv6 address\&.

.PP
\fBParameters\fP
.RS 4
\fIhost\fP The string representing the IPv6 address\&.
.RE
.PP
\fBReturns\fP
.RS 4
1 if the string is a valid IPv6 address, 0 otherwise\&. 
.RE
.PP

.PP
Definition at line \fB571\fP of file \fBnosa\&.h\fP\&.
.SS "NTSTATUS nosa_connect (HANDLE * hSocket, char * host, int port, const char * socketType)"
Establishes a connection using nosa with the specified parameters\&.

.PP
\fBParameters\fP
.RS 4
\fIhSocket\fP Pointer to the socket handle\&. 
.br
\fIhost\fP The host to connect to\&. 
.br
\fIport\fP The port number to connect to\&. 
.br
\fIsocketType\fP The type of socket to use (e\&.g\&., 'TCP')\&.
.RE
.PP
\fBReturns\fP
.RS 4
NTSTATUS indicating the status of the connection attempt\&. 
.RE
.PP

.PP
Definition at line \fB1703\fP of file \fBnosa\&.h\fP\&.
.SS "NTSTATUS nosa_dns_lookup (HANDLE hSocket, const char * domain_name, \fBDOMAIN_INFO\fP * outBuffer)"
lookups a domain name to an IP address using the specified socket handle\&.

.PP
\fBParameters\fP
.RS 4
\fIhSocket\fP The handle to the socket for DNS resolution\&. 
.br
\fIdomain_name\fP The domain name to lookup\&. 
.br
\fIoutBuffer\fP Pointer to a DOMAIN_INFO structure to store the lookupd IP address\&.
.RE
.PP
\fBReturns\fP
.RS 4
NTSTATUS The status of the domain resolution operation\&. 
.RE
.PP

.PP
Definition at line \fB1574\fP of file \fBnosa\&.h\fP\&.
.SS "NTSTATUS nosa_recv (HANDLE hSocket, LPVOID packet_data_received)"
Receives data from a socket using the Windows Socketless API\&.

.PP
\fBParameters\fP
.RS 4
\fIhSocket\fP The handle to the socket from which to receive data\&. 
.br
\fIpacket_data_received\fP Pointer to the buffer where the received data will be stored\&.
.RE
.PP
\fBReturns\fP
.RS 4
NTSTATUS The status of the operation\&. 
.RE
.PP

.PP
Definition at line \fB1877\fP of file \fBnosa\&.h\fP\&.
.SS "NTSTATUS nosa_send (HANDLE * hSocket, LPVOID packet_data, int packet_data_sz)"
Sends a packet of data using the Windows Socket API-less method\&.

.PP
\fBParameters\fP
.RS 4
\fIhSocket\fP A pointer to the socket handle\&. 
.br
\fIpacket_data\fP A pointer to the data packet to be sent\&. 
.br
\fIpacket_data_sz\fP The size of the data packet\&.
.RE
.PP
\fBReturns\fP
.RS 4
The status of the send operation\&. 
.RE
.PP

.PP
Definition at line \fB1850\fP of file \fBnosa\&.h\fP\&.
.SS "USHORT ntohs (USHORT netshort)"
Converts a 16-bit number from network byte order to host byte order\&.

.PP
\fBParameters\fP
.RS 4
\fInetshort\fP The 16-bit number in network byte order\&.
.RE
.PP
\fBReturns\fP
.RS 4
The 16-bit number in host byte order\&. 
.RE
.PP

.PP
Definition at line \fB671\fP of file \fBnosa\&.h\fP\&.
.SS "unsigned int parse_dns_response (unsigned char * response, int response_len)"
Parses a DNS response to extract the IP address\&.

.PP
\fBParameters\fP
.RS 4
\fIresponse\fP The DNS response buffer\&. 
.br
\fIresponse_len\fP The length of the DNS response buffer\&.
.RE
.PP
\fBReturns\fP
.RS 4
The extracted IP address as an unsigned integer\&. 
.RE
.PP

.PP
Definition at line \fB903\fP of file \fBnosa\&.h\fP\&.
.SH "Variable Documentation"
.PP 
.SS "const GUID GUID_NULL"
\fBInitial value:\fP
.nf
= { 
    0x00000000, 0x0000, 0x0000, 
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } }
.PP
.fi

.PP
Definition at line \fB91\fP of file \fBnosa\&.h\fP\&.
.SS "\fBNtClose_t\fP NtClose"

.PP
Definition at line \fB503\fP of file \fBnosa\&.h\fP\&.
.SS "\fBNtCreateEvent_t\fP NtCreateEvent"

.PP
Definition at line \fB504\fP of file \fBnosa\&.h\fP\&.
.SS "\fBNtCreateFile_t\fP NtCreateFile"

.PP
Definition at line \fB505\fP of file \fBnosa\&.h\fP\&.
.SS "\fBNtDeviceIoControlFile_t\fP NtDeviceIoControlFile"

.PP
Definition at line \fB506\fP of file \fBnosa\&.h\fP\&.
.SS "\fBNtWaitForSingleObject_t\fP NtWaitForSingleObject"

.PP
Definition at line \fB507\fP of file \fBnosa\&.h\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Lib Nosa (No Socket API) from the source code\&.
